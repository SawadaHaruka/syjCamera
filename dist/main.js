/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/cheek.js":
/*!**********************!*\
  !*** ./src/cheek.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"cheekL\": () => (/* binding */ cheekL),\n/* harmony export */   \"cheekR\": () => (/* binding */ cheekR),\n/* harmony export */   \"arrBtn_cheek\": () => (/* binding */ arrBtn_cheek),\n/* harmony export */   \"cheek_color\": () => (/* binding */ cheek_color),\n/* harmony export */   \"current_cheekColor\": () => (/* binding */ current_cheekColor)\n/* harmony export */ });\n/* harmony import */ var _imgProcessing__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./imgProcessing */ \"./src/imgProcessing.js\");\n\n/**\n * ほっぺ\n */\nclass cheekL extends createjs.Shape {\n  constructor() {\n    super();\n  }\n  set_cheek(cheekSize, cheekLx, cheekLy, cheekColor) {\n    this.graphics.beginFill(cheekColor).drawCircle(0, 0, cheekSize);\n    this.x = cheekLx;\n    this.y = cheekLy;\n    this.alpha = 0.6;\n    let blurFilter = new createjs.BlurFilter(20, 20, 1); //ボカシのサイズ,サイズ、クオリティーステップ\n    _imgProcessing__WEBPACK_IMPORTED_MODULE_0__.maskImg.cache(0, 0, 500, 500);//先にマスクをキャッシュしておく\n    let maskFilter = new createjs.AlphaMaskFilter(_imgProcessing__WEBPACK_IMPORTED_MODULE_0__.maskImg.cacheCanvas);\n    this.filters = [blurFilter, maskFilter];\n    this.cache(-50, -50, 400, 400);//フィルターをかける本体はフィルターをかけた後にキャッシュする\n  }\n}\nclass cheekR extends cheekL {\n  constructor() {\n    super();\n  }\n}\nconst btn_c1 = document.querySelector(\"#btn_c1\"),\n  btn_c2 = document.querySelector(\"#btn_c2\"),\n  btn_c3 = document.querySelector(\"#btn_c3\"),\n  btn_c4 = document.querySelector(\"#btn_c4\"),\n  btn_c5 = document.querySelector(\"#btn_c5\"),\n  btn_c6 = document.querySelector(\"#btn_c6\");\nconst arrBtn_cheek = [btn_c1, btn_c2, btn_c3, btn_c4, btn_c5, btn_c6];\nconst cheek_img = {\n  value: \"img1\"\n};\nbtn_c1.addEventListener('click', () => { cheek_img.value = \"img1\"; });\nbtn_c2.addEventListener('click', () => { cheek_img.value = \"img2\"; });\nbtn_c3.addEventListener('click', () => { cheek_img.value = \"img3\"; });\nbtn_c4.addEventListener('click', () => { cheek_img.value = \"img4\"; });\nbtn_c5.addEventListener('click', () => { cheek_img.value = \"img5\"; });\nbtn_c6.addEventListener('click', () => { cheek_img.value = \"img6\"; });\n\nconst select_cheekColor = (btn_num) => {\n  const selected_cheekColor = document.querySelectorAll(\"#icons_cheekColor img\");\n  selected_cheekColor.forEach((value) => {\n    value.style.backgroundColor = \"#a38a64\";\n  });\n  btn_num.style.backgroundColor = \"#0dabb7\";\n}\nlet cheek_color;\nconst current_cheekColor = () => {\n  switch (cheek_img.value) {\n    case \"img1\":\n      cheek_color = \"#ef89b2\";\n      select_cheekColor(btn_c1);\n      break;\n    case \"img2\":\n      cheek_color = \"#cc0000\";\n      select_cheekColor(btn_c2);\n      break;\n    case \"img3\":\n      cheek_color = \"#d14bb4\";\n      select_cheekColor(btn_c3);\n      break;\n    case \"img4\":\n      cheek_color = \"#fca88e\";\n      select_cheekColor(btn_c4);\n      break;\n    case \"img5\":\n      cheek_color = \"#ff6600\";\n      select_cheekColor(btn_c5);\n      break;\n    case \"img6\":\n      cheek_color = \"#cc00ff\";\n      select_cheekColor(btn_c6);\n      break;\n  }\n}\n\n//# sourceURL=webpack://syjcamera/./src/cheek.js?");

/***/ }),

/***/ "./src/dlEvt.js":
/*!**********************!*\
  !*** ./src/dlEvt.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"dlName\": () => (/* binding */ dlName),\n/* harmony export */   \"downloadImgs\": () => (/* binding */ downloadImgs)\n/* harmony export */ });\n//ファイル名の重複を避けるため、現在時刻を取得してファイル名にする\nconst dlName = () => {\n  let time = new Date();\n  let month = time.getMonth();\n  let date = time.getDate();\n  let hours = time.getHours();\n  let minutes = time.getMinutes();\n  let seconds = time.getSeconds();\n  let nameOfFile = \"icon\" + month + 1 + date + \"_\" + hours + minutes + seconds + \".png\";\n  return nameOfFile;\n}\n\nconst downloadImgs = (blob) => {\n  let url = URL.createObjectURL(blob);\n  let a = document.createElement(\"a\");\n  document.body.appendChild(a);\n  a.download = dlName();\n  a.href = url;\n  a.click();\n  a.remove();\n  setTimeout(() => {\n    URL.revokeObjectURL(url);\n  }, 2000);\n}\n\n//# sourceURL=webpack://syjcamera/./src/dlEvt.js?");

/***/ }),

/***/ "./src/header.js":
/*!***********************!*\
  !*** ./src/header.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Header\": () => (/* binding */ Header)\n/* harmony export */ });\nclass Header {\n  constructor() {\n    //メニューをトグル\n    const btn = document.querySelector('.hamburger');\n    const nav = document.querySelector('.menu');\n\n    let opened = true;\n\n    btn.addEventListener('click', () => {\n      btn.classList.toggle('active');\n      nav.classList.toggle('open');\n\n      //メニューを開いているときはスクロールできないようにする\n      if (opened === true) {\n        //スクロール禁止\n        document.addEventListener('touchmove', disableScroll, { passive: false });\n        document.body.classList.add('overflow-hidden');\n        opened = false;\n      } else if (opened === false) {\n        //スクロール禁止を解除\n        document.removeEventListener('touchmove', disableScroll, { passive: false });\n        document.body.classList.remove('overflow-hidden');\n        opened = true;\n      }\n    });\n\n    //スクロールを禁止にする関数\n    const disableScroll = (evt) => {\n      evt.preventDefault();\n    }\n\n  }\n}\n\n//# sourceURL=webpack://syjcamera/./src/header.js?");

/***/ }),

/***/ "./src/hige.js":
/*!*********************!*\
  !*** ./src/hige.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"hige_arr\": () => (/* binding */ hige_arr),\n/* harmony export */   \"removeHige\": () => (/* binding */ removeHige),\n/* harmony export */   \"stage_hige\": () => (/* binding */ stage_hige),\n/* harmony export */   \"arrBtn_hige\": () => (/* binding */ arrBtn_hige),\n/* harmony export */   \"current_hige\": () => (/* binding */ current_hige)\n/* harmony export */ });\nclass Hige extends createjs.Bitmap {\n  constructor(img) {\n    super(img);\n    this.regX = 220 / 2; //画像の真ん中が原点\n    this.regY = 0; //画像の一番上が原点\n  }\n  initHige(posX, posY, scale, rotation) {\n    this.x = posX;\n    this.y = posY;\n    this.scale = scale;\n    this.rotation = rotation;//ラジアンを角度に直す\n  }\n}\nclass Hige1 extends Hige {\n  constructor() {\n    super(\"../src/img/img_higeStamp/hige1.png\");\n    this.regY = 90;\n  }\n}\nclass Hige2 extends Hige {\n  constructor() {\n    super(\"../src/img/img_higeStamp/hige2.png\");\n    this.regX = 580 / 2;\n  }\n}\nclass Hige3 extends Hige {\n  constructor() {\n    super(\"../src/img/img_higeStamp/hige3.png\");\n    this.regX = 280 / 2;\n  }\n}\nclass Hige4 extends Hige {\n  constructor() {\n    super(\"../src/img/img_higeStamp/hige4.png\");\n  }\n}\nclass Hige5 extends Hige {\n  constructor() {\n    super(\"../src/img/img_higeStamp/hige5.png\");\n  }\n}\nclass Hige6 extends Hige {\n  constructor() {\n    super(\"../src/img/img_higeStamp/hige6.png\");\n    this.regX = 320 / 2;\n  }\n}\n\nconst hige1 = new Hige1(),\n  hige2 = new Hige2(),\n  hige3 = new Hige3(),\n  hige4 = new Hige4(),\n  hige5 = new Hige5(),\n  hige6 = new Hige6();\nconst hige_arr = [hige1, hige2, hige3, hige4, hige5, hige6];\n\nconst removeHige = () => {\n  hige_arr.forEach((value) => {\n    stage_hige.removeChild(value);\n  });\n}\n\nconst stage_hige = new createjs.Stage(\"canvasHige\");\n\nconst btn_h1 = document.querySelector(\"#btn_h1\"),\n  btn_h2 = document.querySelector(\"#btn_h2\"),\n  btn_h3 = document.querySelector(\"#btn_h3\"),\n  btn_h4 = document.querySelector(\"#btn_h4\"),\n  btn_h5 = document.querySelector(\"#btn_h5\"),\n  btn_h6 = document.querySelector(\"#btn_h6\");\nconst arrBtn_hige = [btn_h1, btn_h2, btn_h3, btn_h4, btn_h5, btn_h6];\nconst hige_img = {\n  value: \"img1\"\n};\nbtn_h1.addEventListener('click', () => { hige_img.value = \"img1\"; });\nbtn_h2.addEventListener('click', () => { hige_img.value = \"img2\"; });\nbtn_h3.addEventListener('click', () => { hige_img.value = \"img3\"; });\nbtn_h4.addEventListener('click', () => { hige_img.value = \"img4\"; });\nbtn_h5.addEventListener('click', () => { hige_img.value = \"img5\"; });\nbtn_h6.addEventListener('click', () => { hige_img.value = \"img6\"; });\n\nconst select_hige=(btn_num)=>{\n  const selected_hige = document.querySelectorAll(\"#icons_hige img\");\n  selected_hige.forEach((value) => {\n    value.style.backgroundColor= \"#a38a64\";\n  });\n  btn_num.style.backgroundColor= \"#0dabb7\";\n}\n\nconst current_hige = () => {\n  switch (hige_img.value) {\n    case \"img1\":\n      removeHige();\n      stage_hige.addChild(hige1);\n      select_hige(btn_h1);\n      break;\n    case \"img2\":\n      removeHige();\n      stage_hige.addChild(hige2);\n      select_hige(btn_h2);\n      break;\n    case \"img3\":\n      removeHige();\n      stage_hige.addChild(hige3);\n      select_hige(btn_h3);\n      break;\n    case \"img4\":\n      removeHige();\n      stage_hige.addChild(hige4);\n      select_hige(btn_h4);\n      break;\n    case \"img5\":\n      removeHige();\n      stage_hige.addChild(hige5);\n      select_hige(btn_h5);\n      break;\n    case \"img6\":\n      removeHige();\n      stage_hige.addChild(hige6);\n      select_hige(btn_h6);\n      break;\n  }\n  stage_hige.update();\n}\n\n//# sourceURL=webpack://syjcamera/./src/hige.js?");

/***/ }),

/***/ "./src/imgProcessing.js":
/*!******************************!*\
  !*** ./src/imgProcessing.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"checkTargetColor\": () => (/* binding */ checkTargetColor),\n/* harmony export */   \"maskImg\": () => (/* binding */ maskImg),\n/* harmony export */   \"noise_light\": () => (/* binding */ noise_light),\n/* harmony export */   \"noise_dark\": () => (/* binding */ noise_dark),\n/* harmony export */   \"canvas_bg\": () => (/* binding */ canvas_bg),\n/* harmony export */   \"bg_context\": () => (/* binding */ bg_context),\n/* harmony export */   \"arrBtn_bg\": () => (/* binding */ arrBtn_bg),\n/* harmony export */   \"current_bg\": () => (/* binding */ current_bg),\n/* harmony export */   \"shadow_light\": () => (/* binding */ shadow_light),\n/* harmony export */   \"shadow_dark\": () => (/* binding */ shadow_dark),\n/* harmony export */   \"lineDrawing\": () => (/* binding */ lineDrawing),\n/* harmony export */   \"lineThickness\": () => (/* binding */ lineThickness)\n/* harmony export */ });\n//色の判定用の関数（引数：現在のピクセルのrgb、指定色の最小値、指定色の最大値）\n//指定したrgb内であれば true を返す\nconst checkTargetColor = (current, min, max) => {\n  if (min.r > current.r || current.r > max.r) return;\n  if (min.g > current.g || current.g > max.g) return;\n  if (min.b > current.b || current.b > max.b) return;\n  return true;\n};\n\nconst maskImg = new createjs.Bitmap(\"../src/img/img_material/maskTex.png\");\n\nconst noise_light = () => {\n  let stage_light = new createjs.Stage(\"canvas_light\");\n  let content_light = new createjs.Bitmap(canvas_light);\n  maskImg.cache(0, 0, 500, 500);\n  let maskFilter = new createjs.AlphaMaskFilter(maskImg.cacheCanvas);\n  content_light.filters = [maskFilter];\n  content_light.cache(-50, -50, 500, 500);//フィルターをかけた後にキャッシュ\n  stage_light.addChild(content_light);\n  stage_light.update();\n}\nconst noise_dark = () => {\n  let stage_dark = new createjs.Stage(\"canvas_dark\");\n  let content_dark = new createjs.Bitmap(canvas_dark);\n  maskImg.cache(0, 0, 500, 500);\n  let maskFilter = new createjs.AlphaMaskFilter(maskImg.cacheCanvas);\n  content_dark.filters = [maskFilter];\n  content_dark.cache(-50, -50, 500, 500);//フィルターをかけた後にキャッシュ\n  stage_dark.addChild(content_dark);\n  stage_dark.update();\n}\n\n\n/**\n * 和紙背景\n */\nconst canvas_bg = document.querySelector(\"#canvas_bg\");\nconst bg_context = canvas_bg.getContext(\"2d\");\nconst bg1 = document.querySelector(\"#bg1\"),\n  bg2 = document.querySelector(\"#bg2\"),\n  bg3 = document.querySelector(\"#bg3\"),\n  bg4 = document.querySelector(\"#bg4\"),\n  bg5 = document.querySelector(\"#bg5\"),\n  bg6 = document.querySelector(\"#bg6\");\nconst btn_bg1 = document.querySelector(\"#btn_bg1\"),\n  btn_bg2 = document.querySelector(\"#btn_bg2\"),\n  btn_bg3 = document.querySelector(\"#btn_bg3\"),\n  btn_bg4 = document.querySelector(\"#btn_bg4\"),\n  btn_bg5 = document.querySelector(\"#btn_bg5\"),\n  btn_bg6 = document.querySelector(\"#btn_bg6\");\nconst arrBtn_bg = [btn_bg1, btn_bg2, btn_bg3, btn_bg4, btn_bg5, btn_bg6];\nconst bg_img = {\n  value: \"img1\"\n};\nbtn_bg1.addEventListener('click', () => { bg_img.value = \"img1\"; });\nbtn_bg2.addEventListener('click', () => { bg_img.value = \"img2\"; });\nbtn_bg3.addEventListener('click', () => { bg_img.value = \"img3\"; });\nbtn_bg4.addEventListener('click', () => { bg_img.value = \"img4\"; });\nbtn_bg5.addEventListener('click', () => { bg_img.value = \"img5\"; });\nbtn_bg6.addEventListener('click', () => { bg_img.value = \"img6\"; });\nconst select_bg = (btn_num) => {\n  const selected_bg = document.querySelectorAll(\"#icons_bg img\");\n  selected_bg.forEach((value) => {\n    value.style.backgroundColor = \"#a38a64\";\n  });\n  btn_num.style.backgroundColor = \"#0dabb7\";\n}\nconst current_bg = () => {\n  switch (bg_img.value) {\n    case \"img1\":\n      bg_context.drawImage(bg1, 0, 0, canvas_bg.width, canvas_bg.height);\n      select_bg(btn_bg1);\n      return;\n    case \"img2\":\n      bg_context.drawImage(bg2, 0, 0, canvas_bg.width, canvas_bg.height);\n      select_bg(btn_bg2);\n      return;\n    case \"img3\":\n      bg_context.drawImage(bg3, 0, 0, canvas_bg.width, canvas_bg.height);\n      select_bg(btn_bg3);\n      return;\n    case \"img4\":\n      bg_context.drawImage(bg4, 0, 0, canvas_bg.width, canvas_bg.height);\n      select_bg(btn_bg4);\n      return;\n    case \"img5\":\n      bg_context.drawImage(bg5, 0, 0, canvas_bg.width, canvas_bg.height);\n      select_bg(btn_bg5);\n      return;\n    case \"img6\":\n      bg_context.drawImage(bg6, 0, 0, canvas_bg.width, canvas_bg.height);\n      select_bg(btn_bg6);\n      return;\n  }\n}\n\n/**\n *opencv公式ドキュメント https://docs.opencv.org/3.4/d2/df0/tutorial_js_table_of_contents_imgproc.html\n *参考ページ(blur) https://qiita.com/shoku-pan/items/07ec25f1d50629fed698\n */\n\n//グレースケール処理\nconst imageGraying = (img) => {\n  let dst = new cv.Mat(); //コンストラクタのことらしい\n  cv.cvtColor(img, dst, cv.COLOR_RGBA2GRAY, 0);//cv.cvtColor(src、dst、コード、0はそのままで）\n  return dst;\n}\n\n//ぼかし処理\nconst imageBlurring = (img, size) => {\n  let src = imageGraying(img); //グレースケール化\n  let ksize = new cv.Size(size, size);//ぼかしサイズ:n*nマス：細かさ(1,1)<…奇数だけ？<(7,7)…<荒い\n  let dst = new cv.Mat();\n  cv.GaussianBlur(src, dst, ksize, 0, 0, cv.BORDER_DEFAULT);\n  return dst;\n}\n\n//薄い影\nconst shadow_light = (img, light_value) => {\n  let src = imageBlurring(img, 3); //ぼかし加工\n  let dst = new cv.Mat();\n  cv.threshold(src, dst, light_value, 255, cv.THRESH_BINARY);//閾値で2値化:引数3で変わる\n  return dst;\n}\n\n//濃い影\nconst shadow_dark = (img, dark_value) => {\n  let src = imageBlurring(img, 3); //ぼかし加工\n  let dst = new cv.Mat();\n  cv.threshold(src, dst, dark_value, 255, cv.THRESH_BINARY);//閾値で2値化:引数3で変わる\n  return dst;\n}\n\n// https://qiita.com/Takarasawa_/items/1556bf8e0513dca34a19\n//線の閾値\nconst lineDrawing = (img, threshold_value) => {\n  let src = imageBlurring(img, 5); //ぼかし加工\n  let dst = new cv.Mat();\n  cv.Canny(src, dst, threshold_value, 85, 3); //輪郭線抽出\n  // cv.Canny(src, dst, 20, 90, 3); //輪郭線抽出\n  let dst2 = new cv.Mat();\n  cv.bitwise_not(dst, dst2); //白黒反転\n  dst.delete(); //使ったもんは削除\n  return dst2;\n}\n\n//線の細さ\nconst lineThickness = (img, threshold_value, thick_value) => {\n  let src = lineDrawing(img, threshold_value);\n  let dst = new cv.Mat();\n  let M = cv.Mat.ones(thick_value, thick_value, cv.CV_8U);//引数1,2で線の太さが変わる\n  cv.erode(src, dst, M, new cv.Point(-1, -1), 1, cv.BORDER_CONSTANT, cv.morphologyDefaultBorderValue());\n  M.delete();\n  return dst;\n}\n\n//# sourceURL=webpack://syjcamera/./src/imgProcessing.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"stage_katsura\": () => (/* binding */ stage_katsura)\n/* harmony export */ });\n/* harmony import */ var _header_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./header.js */ \"./src/header.js\");\n/* harmony import */ var _katsura_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./katsura.js */ \"./src/katsura.js\");\n/* harmony import */ var _imgProcessing_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./imgProcessing.js */ \"./src/imgProcessing.js\");\n/* harmony import */ var _cheek_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cheek.js */ \"./src/cheek.js\");\n/* harmony import */ var _hige_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./hige.js */ \"./src/hige.js\");\n/* harmony import */ var _dlEvt_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./dlEvt.js */ \"./src/dlEvt.js\");\n\n\n\n\n\n\n\nconst stage_katsura = new createjs.Stage(\"canvasStamp\");\n\nclass pageMain {\n  constructor() {\n    document.addEventListener('DOMContentLoaded', this.init(), false);\n  }\n  init() {\n    console.log(\"DOMContentLoaded\");\n    const header = new _header_js__WEBPACK_IMPORTED_MODULE_0__.Header();\n\n    let tracking_state = \"wait\";\n    const log = document.querySelector(\"#log\"); // ログ表示用\n    const count_log_ver = document.querySelector(\"#count_log_ver\");\n    const count_log = document.querySelector(\"#count_log\");\n    const progress_log = document.querySelector(\"#progress_log\");\n    const navi = document.querySelector(\"#progress_img\");\n\n    const video = document.querySelector(\"#video\"); // video 要素を取得\n    const overlay_canvas = document.querySelector(\"#overlay_canvas\");\n    const overlay_context = overlay_canvas.getContext(\"2d\");\n    const canvasStamp = document.querySelector(\"#canvasStamp\");\n    const canvasStamp_color = document.querySelector(\"#canvasStamp_color\");\n    const stamp_color_context = canvasStamp_color.getContext(\"2d\");\n    const canvasB = document.querySelector(\"#canvasB\");//beforeのB\n    const contextB = canvasB.getContext(\"2d\");\n    const wireframe_canvasB = document.querySelector(\"#wireframe_canvasB\"); // トラッキング結果の表示用\n    const wire_contextB = wireframe_canvasB.getContext(\"2d\");\n    const canvasA = document.querySelector(\"#canvasA\");\n    const contextA = canvasA.getContext(\"2d\");\n    const dataOnly_canvas500 = document.querySelector(\"#dataOnly_canvas500\");\n    const data_context500 = dataOnly_canvas500.getContext(\"2d\", { alpha: false });\n    const dataOnly_canvas375 = document.querySelector(\"#dataOnly_canvas375\");\n    const data_context375 = dataOnly_canvas375.getContext(\"2d\", { alpha: false });\n    const btnB = document.querySelector(\"#btnB\");\n    const btnA = document.querySelector(\"#btnA\");\n\n    const canvas_hige = document.querySelector(\"#canvasHige\");\n\n    //画像加工ゾーンのやつ読み込み\n    const canvas_light = document.querySelector(\"#canvas_light\");\n    const light_context = canvas_light.getContext(\"2d\");\n    const canvas_dark = document.querySelector(\"#canvas_dark\");\n    const dark_context = canvas_dark.getContext(\"2d\");\n    const canvas_cheek = document.querySelector(\"#canvas_cheek\");\n    const canvas_line = document.querySelector(\"#canvas_line\");\n    const line_context = canvas_line.getContext(\"2d\");\n\n    //加工ゾーン入力\n    const bar_light = document.querySelector(\"#bar_light\");\n    const color_light = document.querySelector(\"#color_light\");\n    const bar_dark = document.querySelector(\"#bar_dark\");\n    const bar_lineThick = document.querySelector(\"#bar_lineThick\");\n    const bar_lineThreshold = document.querySelector(\"#bar_lineThreshold\");\n    let light_value = 120;\n    let dark_value = 60;\n    let thick_value = 1;\n    let threshold_value = 80;\n\n    //ダウンロード処理パート\n    const btn_dl = document.querySelector(\"#btn_dl\");\n    let dl_canvas = document.querySelector(\"#dl_canvas\");\n    const dl_context = dl_canvas.getContext(\"2d\");\n\n    window.addEventListener('load', () => {\n      console.log(\"windowLoaded\");\n      let videoWidth, videoHeight;\n      let viewportWidth = document.documentElement.clientWidth;//解像度が関係ないwindow内の大きさ？\n      let viewportHeight = document.documentElement.clientHeight;\n      let viewport = \"\";\n      setTimeout(() => {\n        window.scrollTo({ top: 0 });\n      }, 300);\n      //カメラ起動ーーーーーーーーーーーーーーーーーーーー\n      if ((viewportHeight >= viewportWidth * 1.2 && viewportWidth >= 600) || (viewportHeight >= viewportWidth * 1.4 && viewportWidth < 600)) { //ipad縦長画面の場合||スマホ\n        viewport = \"tab_sp\";\n        console.log(\"iPadかスマホの縦画面ですね\");\n        videoWidth = 400;\n        video.width = video.height = overlay_canvas.width = canvasStamp.width = canvasStamp_color.width = canvas_hige.width = canvas_hige.height = overlay_canvas.height = canvasStamp.height = canvasStamp_color.height = videoWidth;\n        navigator.mediaDevices.getUserMedia({\n          video: {\n            facingMode: \"user\", //インカメラ\n            width: videoWidth, //正方形で取る\n            height: videoWidth, //正方形で取る\n          }, audio: false,\n        }).then((stream) => { //メディアデバイスが取得できたら\n          video.srcObject = stream; //video要素にストリームを渡す\n        });\n        canvasB.width = wireframe_canvasB.width = canvasA.width = canvasB.height = wireframe_canvasB.height = canvasA.height = 300;\n      } else { //パソコン\n        viewport = \"pc\";\n        console.log(\"パソコンorスマホ/タブレットの横画面ですね。\");\n        videoWidth = 500;\n        videoHeight = 375;\n        video.width = videoWidth;\n        video.height = videoHeight;\n        overlay_canvas.width = canvasStamp.width = canvasStamp_color.width = canvas_hige.width = videoWidth;//pc\n        overlay_canvas.height = canvasStamp.height = canvasStamp_color.height = canvas_hige.height = videoHeight;//pc\n        navigator.mediaDevices.getUserMedia({\n          video: {\n            facingMode: \"user\",\n            width: videoWidth,\n            height: videoHeight,\n          }, audio: false,\n        }).then((stream) => {\n          video.srcObject = stream;\n        });\n        canvasB.width = wireframe_canvasB.width = canvasA.width = 400;\n        canvasB.height = wireframe_canvasB.height = canvasA.height = 300;\n        dataOnly_canvas500.width = 500;\n        dataOnly_canvas500.height = 375;\n      }\n      canvas_light.width = canvas_light.height = _imgProcessing_js__WEBPACK_IMPORTED_MODULE_2__.canvas_bg.width = _imgProcessing_js__WEBPACK_IMPORTED_MODULE_2__.canvas_bg.height = canvas_dark.width = canvas_dark.height = canvas_cheek.width = canvas_cheek.height = canvas_line.width = canvas_line.height = 375;\n\n      // clmtrackrをインスタンス化\n      const ctrack = new clm.tracker();\n      ctrack.init(pModel);\n\n      //createjs\n      createjs.Ticker.addEventListener('tick', stage_katsura); //Tickerデフォルトは24fpsで描画更新\n      const stage_cheek = new createjs.Stage(\"canvas_cheek\");\n\n      //スタートボタンーーーーーーーーーーーーーーーーーーーーーーーー\n      const start_triger = document.querySelector(\"#start_triger\");\n      start_triger.addEventListener(\"click\", () => {\n        tracking_state = \"start\";\n        video.play();//念の為？\n        createjs.Ticker.addEventListener(\"tick\", drawLoop);\n        ctrack.start(video);\n        start_triger.style.display = \"none\";\n        btnB.style.display = \"block\";\n        navi.style.visibility = \"visible\";\n        progress_log.innerHTML = \"緑の線が顔についてくるか確認しよう！<br>前髪を分けると認識されやすいよ\";\n      });\n\n      let positions; //顔部品（特徴点）の位置データを表示する用\n      const drawLoop = () => { //描画ループの関数\n        createjs.Ticker.addEventListener(\"tick\", drawLoop);\n        positions = ctrack.getCurrentPosition(); // 顔部品の現在位置の取得\n        overlay_context.clearRect(0, 0, overlay_canvas.width, overlay_canvas.height); //canvasクリア\n        ctrack.draw(overlay_canvas); // canvasにトラッキング結果を描画\n        stamp_color_context.clearRect(0, 0, canvasStamp_color.width, canvasStamp_color.height);\n        stamp_color_context.drawImage(canvasStamp, 0, 0, canvasStamp_color.width, canvasStamp_color.height);\n        if (positions) { //座標が取得できたら\n          getPos(positions);\n        }\n      }\n\n      const drawStamp = () => {\n        //顔の幅にスタンプを合わせる\n        let faceWidth = faceLX - faceRX; //幅の基準としてこめかみの間隔を求める\n        let imgWidth = 0.55 * faceWidth; // 顔幅をもとに画像の幅を変える\n        let imgSize = imgWidth / -110; //ちょっと調整\n        //スタンプを回転させるための角度を求める（ラジアンで取得される）\n        let stampRadian = Math.atan2(faceRY - faceLY, faceRX - faceLX);\n        let degree = stampRadian * 180 / Math.PI;\n        _katsura_js__WEBPACK_IMPORTED_MODULE_1__.katsura_arr.forEach((value) => {\n          value.initStamp(bikonX, bikonY, imgSize, degree);\n        });\n\n        //かつらの肌色部分の色を変える\n        const currentColor_face = { r: null, g: null, b: null };\n        let imageData = stamp_color_context.getImageData(0, 0, canvasStamp_color.width, canvasStamp_color.height); //コンテキストからデータ取得\n        let data_k = imageData.data;\n        for (let i = 0, len = imageData.data.length; i < len; i += 4) {//rgba4バイトずつ取得\n          currentColor_face.r = data_k[i];\n          currentColor_face.g = data_k[i + 1];\n          currentColor_face.b = data_k[i + 2];\n          // 画像の白色部分を取得した肌色に変換する\n          if ((0,_imgProcessing_js__WEBPACK_IMPORTED_MODULE_2__.checkTargetColor)(currentColor_face, minColor_white, maxColor_white)) {\n            data_k[i] = r_avg;\n            data_k[i + 1] = g_avg;\n            data_k[i + 2] = b_avg;\n          }\n        }\n        stamp_color_context.putImageData(imageData, 0, 0);//canvasに変更済みのImageDataオブジェクトを描画する\n      }\n\n      /**\n      * 真顔ー変顔：鼻根と各点の距離間を真顔では1とし、変顔では絶対値に直してxとする。\n      * 顔をクシャッと縮めて距離（比率）がマイナスなった場合(1-x)+1=2-xに直す\n      */\n      let arrBefore, arrAfter, arrSum;\n      let faceLX, faceLY, faceRX, faceRY, bikonX, bikonY, faceSizeB, faceSizeA, ratioFace, faceSize, cheekLx, cheekLy, cheekRx, cheekRy, h37x, h37y;\n      const getPos = (pos) => {\n        bikonX = pos[33][0];\n        bikonY = pos[33][1];\n        let num = (a) => { // 距離を求めて絶対値に直しておく:pos[33][]は鼻根の座標\n          return Math.abs(Math.sqrt((bikonX - pos[a][0]) ** 2 + (bikonY - pos[a][1]) ** 2));\n        }\n        //眉毛\n        let eb16 = num(16),\n          eb20 = num(20),\n          eb18 = num(18),\n          eb22 = num(22),\n          //目\n          e29 = num(29),\n          e24 = num(24),\n          e31 = num(31),\n          e26 = num(26),\n          //鼻頭\n          bt62 = num(62),\n          //口\n          m50 = num(50),\n          m44 = num(44),\n          m57 = num(57),\n          m60 = num(60),\n          //顎\n          j6 = num(6),\n          j8 = num(8),\n          //頬\n          c11 = num(11),\n          c3 = num(3);\n        let getCheekPos = () => {\n          if (viewport == \"tab_sp\") {\n            cheekLx = Math.abs(pos[40][0] - pos[13][0]) / 2 + pos[40][0] * 375 / 400;\n            cheekLy = Math.abs(pos[40][1] - pos[13][1]) / 2 + pos[13][1] * 375 / 400;\n            cheekRx = Math.abs(pos[34][0] - pos[1][0]) / 2 + pos[1][0] * 375 / 400;\n            cheekRy = Math.abs(pos[34][1] - pos[1][1]) / 2 + pos[1][1] * 375 / 400;\n          } else if (viewport == \"pc\") {\n            cheekLx = Math.abs(pos[40][0] - pos[13][0]) / 2 + pos[40][0] - 62.5;\n            cheekLy = Math.abs(pos[40][1] - pos[13][1]) / 2 + pos[13][1];\n            cheekRx = Math.abs(pos[34][0] - pos[1][0]) / 2 + pos[1][0] - 62.5;\n            cheekRy = Math.abs(pos[34][1] - pos[1][1]) / 2 + pos[1][1];\n          }\n        }\n        const getHigePos = () => {\n          h37x = pos[37][0];\n          h37y = pos[37][1];\n        }\n        faceLX = pos[0][0]; // こめかみRのX座標\n        faceLY = pos[0][1]; // こめかみRのY座標\n        faceRX = pos[14][0]; // こめかみLのX座標\n        faceRY = pos[14][1]; // こめかみLのY座標\n        faceSize = Math.abs(Math.sqrt((faceLX - faceRX) ** 2 + (faceLY - faceRY) ** 2));\n        if (tracking_state === \"before\") {//トラッキングが成功し終わるとbtnAへ切り替わる\n          arrBefore = []; //配列クリア\n          arrBefore = [eb16, eb20, eb18, eb22, e29, e24, e31, e26, bt62, m50, m44, m57, m60, j6, j8, c11, c3];\n          faceSizeB = Math.abs(Math.sqrt((faceLX - faceRX) ** 2 + (faceLY - faceRY) ** 2));\n        } else if (tracking_state === \"selectKatsura\") {\n          drawStamp();\n        } else if (tracking_state === \"autoShutter\") {//変顔を測り続ける\n          drawStamp();\n          arrAfter = []; arrSum = [];//撮り直し用に配列クリア\n          arrAfter = [eb16, eb20, eb18, eb22, e29, e24, e31, e26, bt62, m50, m44, m57, m60, j6, j8, c11, c3];\n          faceSizeA = Math.abs(Math.sqrt((faceLX - faceRX) ** 2 + (faceLY - faceRY) ** 2));\n          // ratioB:ratioA=1:ratioFaceで求められたxを各距離感に積算する\n          ratioFace = faceSizeA / faceSizeB;\n          // console.log(\"顔の大きさはafterの方が\", ratioFace, \"倍違う\");\n\n          //比率を揃えるために顔の大きさの比率で割った配列\n          let arrAfter_RE = arrAfter.map(item => item / ratioFace);\n\n          for (let i = 0; i < arrAfter.length; i++) {\n            let element = arrAfter_RE[i] / arrBefore[i]; // それぞれの特徴点before:afterで比率が出る\n            if (element < 1) {//顔をクシャッと縮めて距離（比率）がマイナスなった場合用に(1-x)+1に直す\n              element = 2 - element;\n            }\n            arrSum.push(element);\n          }\n          let sum = arrSum.reduce((sum, elem) => sum + elem, 0);\n          if (sum >= arrAfter.length + 0.8) {//変形した顔の値の閾値\n            hengao = true;\n            if (passedTime >= setCount) {\n              clearTimeout(timerID);\n              getCheekPos();\n              getHigePos();\n              photographing(); //撮影時のイベント\n            }\n          } else { //真顔状態に戻ったとき\n            hengao = false;\n          }\n        } else if (tracking_state == \"usingButton\") {\n          drawStamp();\n          if (passedTime >= setCount) {\n            clearTimeout(timerID);\n            getCheekPos();\n            getHigePos();\n            photographing(); //撮影時のイベント\n          }\n        }\n      }\n\n      let faceColor_r, faceColor_g, faceColor_b, r_avg, g_avg, b_avg, arrFace_r, arrFace_g, arrFace_b;\n      const ctrackConverged = () => {\n        console.log(\"トラッキング成功\");\n        remove_ctrackEvent();\n        setTimeout(() => { //顔検出が成功し終わるまで時間を置いてから再開\n          reTracking();\n        }, 1500);\n\n        positions = ctrack.getCurrentPosition(); // 顔部品の現在位置の取得再開\n        if (positions) { //顔部品の現在位置を取得したら\n          getPos(positions);\n          wire_contextB.clearRect(0, 0, wireframe_canvasB.width, wireframe_canvasB.height);\n          ctrack.stop(video);\n          ctrack.draw(wireframe_canvasB); //トラッキング結果をワイヤーフレームに描画\n\n          //肌色の取得------------------------------------------------------------\n          let pos1x = Math.round(positions[1][0]); //X座標（四捨五入して整数に）\n          let pos1y = Math.round(positions[1][1]); //Y座標（四捨五入して整数に）\n          let pos13x = Math.round(positions[13][0]);\n          const facecColorData = contextB.getImageData(pos1x, pos1y, pos13x - pos1x, 1);\n          const colordata = facecColorData.data;\n          arrFace_r = []; arrFace_g = []; arrFace_b = [];//一旦空にする\n          for (let i = 0; i < facecColorData.width * facecColorData.height * 4; i += 4) {\n            faceColor_r = colordata[i];//r\n            faceColor_g = colordata[i + 1];//g\n            faceColor_b = colordata[i + 2];//b\n            arrFace_r.push(faceColor_r);\n            arrFace_g.push(faceColor_g);\n            arrFace_b.push(faceColor_b);\n          }\n          let r_sum = arrFace_r.reduce((sum, elem) => sum + elem, 0);\n          r_avg = r_sum / arrFace_r.length;\n          let g_sum = arrFace_g.reduce((sum, elem) => sum + elem, 0);\n          g_avg = g_sum / arrFace_g.length;\n          let b_sum = arrFace_b.reduce((sum, elem) => sum + elem, 0);\n          b_avg = b_sum / arrFace_b.length;\n        }\n        //案内------------------------------------------------------------\n        btnB.style.display = \"none\";\n        _katsura_js__WEBPACK_IMPORTED_MODULE_1__.stamp_btn.forEach((value) => {//出現\n          value.style.display = \"inline-block\";\n        });\n        _katsura_js__WEBPACK_IMPORTED_MODULE_1__.tween_btns.play();//スタンプ用のボタン登場\n\n        log.innerHTML = \"【二】かつらを選んでね。\";\n        progress_log.innerHTML = \"全力で変顔をしてみよう。<br>大きく顔を変化させられれば自動で撮影カウントが始まるよォ\";\n\n        setTimeout(() => {\n          if (tracking_state == \"autoShutter\") {\n            progress_log.innerHTML = \"なかなか撮れてないみたいだね。大変！<br>このボタンを押してみると良いよ。すぐ撮影できるゾ\";\n            btnA.style.display = \"inline-block\";\n          }\n        }, 28000);\n      }\n      const ctrackFailed = () => {\n        log.innerHTML = \"トラッキング失敗、もう一度撮影してください\";\n        remove_ctrackEvent();\n        setTimeout(() => { //顔検出が成功し終わるまで時間を置いてから再開\n          reTracking();\n        }, 1500);\n      }\n      const remove_ctrackEvent = () => {\n        document.removeEventListener('clmtrackrConverged', ctrackConverged, false); //トラッキング成功\n        document.removeEventListener('clmtrackrNotFound', ctrackFailed, false); //顔検出失敗\n        document.removeEventListener('clmtrackrLost', ctrackFailed, false); //トラッキング失敗\n      }\n      const setTracking = () => { // トラッキング用セット\n        document.addEventListener('clmtrackrConverged', ctrackConverged, false); //トラッキング成功\n        document.addEventListener('clmtrackrNotFound', ctrackFailed, false); //顔検出失敗\n        document.addEventListener('clmtrackrLost', ctrackFailed, false); //トラッキング失敗\n      }\n      const reTracking = () => {\n        ctrack.stop(canvasB);\n        ctrack.reset();\n        ctrack.start(video); //videoのトラッキング再スタート\n      }\n      let hengao = null,\n        timerID, //setTimeoutをclearTimeoutするときに必要なtimerID\n        setCount = 6, //カウント秒数\n        passedTime = 0;\n      //1秒ごとに実行される関数\n      const countTime = () => {\n        if (hengao == true) {//変形した顔の値の閾値\n          passedTime++;//経過秒数\n          let countDown = setCount - passedTime;//残り秒数\n          count_log.innerHTML = \"撮影まで<br>\" + countDown;//残り秒数表示\n        } else if (hengao == false) { //真顔に近くなったらカウントリセット\n          passedTime = 0;\n          count_log.innerHTML = \"撮影まで<br>\";\n        }\n        timerID = setTimeout(countTime, 1000);\n      }\n      btnB.addEventListener('click', () => { //検出ボタンBeforeを押したら\n        tracking_state = \"before\";\n        contextB.clearRect(0, 0, canvasB.width, canvasB.height); //canvasクリア\n        contextB.drawImage(video, 0, 0, canvasB.width, canvasB.height); //canvasに動画を切り出して転写\n        wire_contextB.clearRect(0, 0, wireframe_canvasB.width, wireframe_canvasB.height);\n        ctrack.stop(video);\n        ctrack.reset(); //videoのトラッキングを止める\n        ctrack.start(canvasB); //canvas内でフェイストラッキング開始\n        setTracking();\n      });\n      _katsura_js__WEBPACK_IMPORTED_MODULE_1__.arrBtn_katsura.forEach((value) => {//どれかカツラボタンをクリックしたら\n        value.addEventListener(\"click\", () => {\n          hengao = false;\n          if (tracking_state == \"autoShutter\") {\n            btnS.style.display = \"none\";\n          } else {\n            tracking_state = \"selectKatsura\";\n            btnS.style.display = \"inline-block\";\n          }\n        });\n      });\n      btnS.addEventListener(\"click\", () => {\n        btnS.style.display = \"none\";\n        tracking_state = \"autoShutter\";\n        log.innerHTML = \"【三】変顔を5秒以上しよう。\";\n        count_log_ver.innerHTML = \"自力で撮影バージョン\";\n        count_log.innerHTML = \"撮影まで<br>\";\n        countTime();//撮影カウントダウン用\n      });\n      const copying500 = () => {\n        //videoを転写したやつから直に正方形にトリミングしようとするとできないっぽいので、非表示canvasに一旦転写\n        data_context500.clearRect(0, 0, dataOnly_canvas500.width, dataOnly_canvas500.height);\n        data_context500.drawImage(canvasA, 0, 0, dataOnly_canvas500.width, dataOnly_canvas500.height);\n        data_context500.drawImage(canvasStamp_color, 0, 0, dataOnly_canvas500.width, dataOnly_canvas500.height);\n      }\n      const copying375 = () => {\n        //アイコンにするために正方形にトリミングする（非表示のcanvas）\n        data_context375.clearRect(0, 0, dataOnly_canvas375.width, dataOnly_canvas375.height);\n        data_context375.drawImage(dataOnly_canvas500, 62.5, 0, dataOnly_canvas375.width, dataOnly_canvas375.height, 0, 0, dataOnly_canvas375.width, dataOnly_canvas375.height);\n        //タブレット・スマホ（縦）の場合はトリミングせずそのまま転写\n        if (viewportHeight >= viewportWidth * 1.2) {\n          data_context375.drawImage(canvasA, 0, 0, dataOnly_canvas375.width, dataOnly_canvas375.height);\n        }\n      }\n      //撮影時のイベント\n      const photographing = () => {\n        //表示されてるやつ（確認用）\n        contextA.clearRect(0, 0, canvasA.width, canvasA.height);\n        contextA.drawImage(video, 0, 0, canvasA.width, canvasA.height); //転写\n        contextA.drawImage(canvasStamp_color, 0, 0, canvasA.width, canvasA.height);\n        copying500();\n        copying375();\n        ctrack.stop(video);\n        createjs.Ticker.removeEventListener('tick', drawLoop); //Tickerイベントを削除しておく\n        createjs.Ticker.removeEventListener('tick', stage_katsura); //Tickerイベントを削除しておく\n        video.pause();\n\n        _katsura_js__WEBPACK_IMPORTED_MODULE_1__.stamp_btn.forEach((value) => {\n          value.style.display = \"none\";\n        });\n\n        tracking_state = \"end\";\n        log.innerHTML = \"【四】撮影完了！\";\n        progress_log.innerHTML = \"撮影完了！<br>いい感じに編集をしてアイコンを作ろう\";\n\n        drawingCombo();//加工する場所に転写\n\n        window.scrollTo(0, document.documentElement.scrollHeight - viewportHeight);//一番下へ移動\n      }\n      //読み取れなかった時のための予備用\n      btnA.addEventListener('click', () => {\n        tracking_state = \"usingButton\";\n        count_log_ver.innerHTML = \"ボタンで撮影バージョン\";\n        hengao = true;\n      });\n\n      /**\n      * 動画の[停止/再開]処理\n      */\n      document.addEventListener('visibilitychange', () => {\n        if (document.visibilityState === 'visible') {\n          switch (tracking_state) {\n            case \"end\":\n              video.pause();\n              createjs.Ticker.removeEventListener('tick', drawLoop); //Tickerイベントを削除しておく\n              ctrack.stop();\n              break;\n            case \"wait\":\n              video.pause();\n              break;\n            case \"start\":\n              video.play();\n              createjs.Ticker.addEventListener(\"tick\", drawLoop); //Tickerをセットする\n              ctrack.start(video);\n              break;\n            default:\n              video.play();\n              createjs.Ticker.addEventListener(\"tick\", drawLoop); //Tickerをセットする\n              ctrack.start(video);\n          }\n\n        } else if (document.visibilityState === 'hidden') {\n          video.pause();\n          createjs.Ticker.removeEventListener('tick', drawLoop); //Tickerイベントを削除しておく\n          ctrack.stop();\n        }\n      });\n\n      // canvasで特定の色を変えるやつの参考\n      // https://qiita.com/chelcat3/items/03419142aea295e94c69\n\n      // 変更したい色の範囲を決めておく（opencvで出力されるのが真っ黒かわからないからちょっと範囲を持たせとく）\n      const minColor_black = { r: 0, g: 0, b: 0 };\n      const maxColor_black = { r: 4, g: 4, b: 4 };\n      const minColor_white = { r: 248, g: 248, b: 248 };\n      const maxColor_white = { r: 255, g: 255, b: 255 };\n      //ここに現在のピクセル情報を入れていく\n      let currentColor = {};//{r:null,g:null,b:null}となる\n\n      //背景和紙レイヤーの変更イベント---------------------------------------------------------\n      _imgProcessing_js__WEBPACK_IMPORTED_MODULE_2__.arrBtn_bg.forEach((value) => {\n        value.addEventListener(\"click\", () => {\n          drawingCombo();\n        });\n      });\n      const reDrawingCanvas = () => {\n        _imgProcessing_js__WEBPACK_IMPORTED_MODULE_2__.bg_context.globalCompositeOperation = \"source-over\";//描画方法ノーマル\n        _imgProcessing_js__WEBPACK_IMPORTED_MODULE_2__.bg_context.clearRect(0, 0, _imgProcessing_js__WEBPACK_IMPORTED_MODULE_2__.canvas_bg.width, _imgProcessing_js__WEBPACK_IMPORTED_MODULE_2__.canvas_bg.height);\n        _imgProcessing_js__WEBPACK_IMPORTED_MODULE_2__.bg_context.drawImage(canvas_light, 0, 0, _imgProcessing_js__WEBPACK_IMPORTED_MODULE_2__.canvas_bg.width, _imgProcessing_js__WEBPACK_IMPORTED_MODULE_2__.canvas_bg.height);\n        _imgProcessing_js__WEBPACK_IMPORTED_MODULE_2__.bg_context.drawImage(canvas_dark, 0, 0, _imgProcessing_js__WEBPACK_IMPORTED_MODULE_2__.canvas_bg.width, _imgProcessing_js__WEBPACK_IMPORTED_MODULE_2__.canvas_bg.height);\n        _imgProcessing_js__WEBPACK_IMPORTED_MODULE_2__.bg_context.drawImage(canvas_cheek, 0, 0, _imgProcessing_js__WEBPACK_IMPORTED_MODULE_2__.canvas_bg.width, _imgProcessing_js__WEBPACK_IMPORTED_MODULE_2__.canvas_bg.height);\n        _imgProcessing_js__WEBPACK_IMPORTED_MODULE_2__.bg_context.globalCompositeOperation = \"multiply\";//描画方法を乗算に\n        (0,_imgProcessing_js__WEBPACK_IMPORTED_MODULE_2__.current_bg)();\n      }\n      //薄い影の変更イベント\n      let r_rgb = 250, g_rgb = 230, b_rgb = 220;\n      const change_shadowLight = () => {\n        light_context.clearRect(0, 0, canvas_light.width, canvas_light.height);\n        let src = cv.imread(dataOnly_canvas375);\n        let dst = (0,_imgProcessing_js__WEBPACK_IMPORTED_MODULE_2__.shadow_light)(src, light_value);\n        cv.imshow('canvas_light', dst);\n        src.delete(); dst.delete();\n        //色（白か黒か）をチェックして自由な色に変える\n        const imgData_l = light_context.getImageData(0, 0, canvas_light.width, canvas_light.height);\n        const data_l = imgData_l.data;\n        for (let i = 0, len = data_l.length; i < len; i += 4) {//rgba4バイトずつ取得\n          currentColor.r = data_l[i];\n          currentColor.g = data_l[i + 1];\n          currentColor.b = data_l[i + 2];\n          // 黒色であれば入力された色に変換する\n          if ((0,_imgProcessing_js__WEBPACK_IMPORTED_MODULE_2__.checkTargetColor)(currentColor, minColor_black, maxColor_black)) {\n            data_l[i] = r_rgb;\n            data_l[i + 1] = g_rgb;\n            data_l[i + 2] = b_rgb;\n            data_l[i + 3] = 255; // アルファ値：0で透明\n          }\n        }\n        // canvasに変更済みのImageDataオブジェクトを描画する\n        light_context.putImageData(imgData_l, 0, 0);\n\n        (0,_imgProcessing_js__WEBPACK_IMPORTED_MODULE_2__.noise_light)(); //かすれ加工\n        reDrawingCanvas(); //変更した時にレイヤーを保持する\n      }\n      color_light.addEventListener('change', () => {\n        let str = color_light.value; //16進数で取得されるので\n        r_rgb = parseInt(str.substr(1, 2), 16); //10進数に直す\n        g_rgb = parseInt(str.substr(3, 2), 16);\n        b_rgb = parseInt(str.substr(5, 2), 16);\n        change_shadowLight();\n      });\n      bar_light.addEventListener('input', () => {\n        light_value = bar_light.value - 0;//string型になっちゃうからnumber型に直す\n        change_shadowLight();\n      });\n\n      //濃い影の変更イベント------------------------------------------------------------\n      const change_shadowDark = () => {\n        dark_context.clearRect(0, 0, canvas_dark.width, canvas_dark.height);\n        let src = cv.imread(dataOnly_canvas375);\n        let dst = (0,_imgProcessing_js__WEBPACK_IMPORTED_MODULE_2__.shadow_dark)(src, dark_value);\n        cv.imshow('canvas_dark', dst);\n        src.delete(); dst.delete();\n        const imgData_d = dark_context.getImageData(0, 0, canvas_dark.width, canvas_dark.height);\n        const data_d = imgData_d.data;\n        for (let i = 0, len = data_d.length; i < len; i += 4) {\n          currentColor.r = data_d[i];\n          currentColor.g = data_d[i + 1];\n          currentColor.b = data_d[i + 2];\n          if ((0,_imgProcessing_js__WEBPACK_IMPORTED_MODULE_2__.checkTargetColor)(currentColor, minColor_white, maxColor_white)) {\n            data_d[i + 3] = 0; //白色部分を透明に\n          }\n          if ((0,_imgProcessing_js__WEBPACK_IMPORTED_MODULE_2__.checkTargetColor)(currentColor, minColor_black, maxColor_black)) {\n            data_d[i] = 60;\n            data_d[i + 1] = 60;\n            data_d[i + 2] = 80;\n            data_d[i + 3] = 255;//不透明\n          }\n        }\n        dark_context.putImageData(imgData_d, 0, 0);\n        (0,_imgProcessing_js__WEBPACK_IMPORTED_MODULE_2__.noise_dark)();\n        reDrawingCanvas();\n      }\n      bar_dark.addEventListener('input', () => {\n        dark_value = bar_dark.value - 0;//string型になっちゃうからnumber型に直す\n        change_shadowDark();\n      });\n\n      //ほっぺの変更イベント------------------------------------------------------------\n      const cheekLeft = new _cheek_js__WEBPACK_IMPORTED_MODULE_3__.cheekL(),\n        cheekRight = new _cheek_js__WEBPACK_IMPORTED_MODULE_3__.cheekR();\n      const add_cheek = () => {\n        let cheekSize = faceSize * 25 / 150;//ほっぺの大きさ\n        (0,_cheek_js__WEBPACK_IMPORTED_MODULE_3__.current_cheekColor)();\n        cheekLeft.set_cheek(cheekSize, cheekLx, cheekLy, _cheek_js__WEBPACK_IMPORTED_MODULE_3__.cheek_color);\n        cheekRight.set_cheek(cheekSize, cheekRx, cheekRy, _cheek_js__WEBPACK_IMPORTED_MODULE_3__.cheek_color);\n        stage_cheek.addChild(cheekLeft, cheekRight);\n        stage_cheek.update();\n        reDrawingCanvas();\n      }\n      const toggle_cheek = document.querySelector(\"#toggle_cheek\");\n      toggle_cheek.checked = false;\n      const icons_cheekColor = document.querySelectorAll(\"#icons_cheekColor li\");\n      icons_cheekColor.forEach((value) => {\n        value.style.display = \"none\";\n      });\n      toggle_cheek.addEventListener('change', () => {\n        if (toggle_cheek.checked == true) {\n          icons_cheekColor.forEach((value) => {\n            value.style.display = \"inline-block\";\n          });\n          add_cheek();\n          _cheek_js__WEBPACK_IMPORTED_MODULE_3__.arrBtn_cheek.forEach((value) => {\n            value.addEventListener(\"click\", () => {\n              add_cheek();\n            });\n          });\n        } else if (toggle_cheek.checked == false) {\n          icons_cheekColor.forEach((value) => {\n            value.style.display = \"none\";\n          });\n          stage_cheek.removeChild(cheekLeft, cheekRight);\n          stage_cheek.update();\n          reDrawingCanvas();\n        }\n      });\n\n      //ひげの変更イベント------------------------------------------------------------\n      const toggle_hige = document.querySelector(\"#toggle_hige\");\n      toggle_hige.checked = false;\n      const icons_hige = document.querySelectorAll(\"#icons_hige li\");\n      icons_hige.forEach((value) => {\n        value.style.display = \"none\";\n      });\n      toggle_hige.addEventListener('change', () => {\n        if (toggle_hige.checked == true) {\n          icons_hige.forEach((value) => {\n            value.style.display = \"inline-block\";\n          });\n          higeCombo();\n          _hige_js__WEBPACK_IMPORTED_MODULE_4__.arrBtn_hige.forEach((value) => {//ヒゲボタンをどれかクリックするたびに\n            value.addEventListener(\"click\", () => {\n              higeCombo();\n            });\n          });\n        } else if (toggle_hige.checked == false) {\n          icons_hige.forEach((value) => {\n            value.style.display = \"none\";\n          });\n          (0,_hige_js__WEBPACK_IMPORTED_MODULE_4__.removeHige)();//ひげ消す\n          copying375();//描き直し\n          drawingCombo();\n        }\n      });\n      const set_hige = () => {\n        let imgScale = 0.55 * faceSize / 110; //ちょっと調整\n        //スタンプを回転させるための角度を求める（ラジアンで取得される）\n        let stampRadian = Math.atan2(faceRY - faceLY, faceRX - faceLX);\n        let degree = stampRadian * 180 / Math.PI;\n        _hige_js__WEBPACK_IMPORTED_MODULE_4__.hige_arr.forEach((value) => {//全部に対して位置を代入\n          value.initHige(h37x, h37y, imgScale, degree);\n        });\n      }\n      const higeDrawing = () => {\n        copying375();//375canvasをクリアして描く\n        data_context375.drawImage(canvas_hige, 0, 0, dataOnly_canvas375.width, dataOnly_canvas375.height);\n      }\n      const higeCombo = () => {\n        set_hige();//ひげを置くための座標を取得する\n        (0,_hige_js__WEBPACK_IMPORTED_MODULE_4__.current_hige)();//stage_higeにひげをaddChild\n        higeDrawing();//375canvasに転写\n        drawingCombo();//それぞれのレイヤーを描き直す\n      }\n\n      //線の変更イベント------------------------------------------------------------\n      const change_line = () => {\n        line_context.clearRect(0, 0, canvas_line.width, canvas_line.height);\n        let src = cv.imread(dataOnly_canvas375);\n        let dst = (0,_imgProcessing_js__WEBPACK_IMPORTED_MODULE_2__.lineThickness)(src, threshold_value, thick_value);\n        cv.imshow('canvas_line', dst);\n        src.delete(); dst.delete();\n        const imageData_line = line_context.getImageData(0, 0, canvas_line.width, canvas_line.height);\n        const data_line = imageData_line.data;\n        for (let i = 0, len = data_line.length; i < len; i += 4) {\n          currentColor.r = data_line[i];\n          currentColor.g = data_line[i + 1];\n          currentColor.b = data_line[i + 2];\n          if ((0,_imgProcessing_js__WEBPACK_IMPORTED_MODULE_2__.checkTargetColor)(currentColor, minColor_white, maxColor_white)) {\n            data_line[i + 3] = 0;\n          }\n          if ((0,_imgProcessing_js__WEBPACK_IMPORTED_MODULE_2__.checkTargetColor)(currentColor, minColor_black, maxColor_black)) {\n            data_line[i] = 60;\n            data_line[i + 1] = 60;\n            data_line[i + 2] = 70;\n            data_line[i + 3] = 255;\n          }\n        }\n        line_context.putImageData(imageData_line, 0, 0);\n      }\n      bar_lineThick.addEventListener('input', () => {//線の太さ\n        thick_value = bar_lineThick.value - 0;\n        change_line();\n      });\n      bar_lineThreshold.addEventListener('input', () => {//ぼかしの閾値\n        threshold_value = bar_lineThreshold.value - 0;\n        change_line();\n      });\n\n      //描き直すときのセット\n      const drawingCombo = () => {\n        change_shadowLight();\n        change_shadowDark();\n        change_line();\n      }\n\n      /**\n       * ダウンロード処理\n       */\n      btn_dl.addEventListener(\"click\", () => {\n        //レイヤーを一個の画像にする\n        dl_context.drawImage(canvas_light, 0, 0, dl_canvas.width, dl_canvas.height);\n        dl_context.drawImage(canvas_dark, 0, 0, dl_canvas.width, dl_canvas.height);\n        dl_context.drawImage(_imgProcessing_js__WEBPACK_IMPORTED_MODULE_2__.canvas_bg, 0, 0, dl_canvas.width, dl_canvas.height);\n        dl_context.drawImage(canvas_line, 0, 0, dl_canvas.width, dl_canvas.height);\n        dl_canvas.toBlob(_dlEvt_js__WEBPACK_IMPORTED_MODULE_5__.downloadImgs);//blob生成\n      });\n\n\n      drawLoop();\n    });\n\n  }\n}\n\nconst page = new pageMain();\n\n//# sourceURL=webpack://syjcamera/./src/index.js?");

/***/ }),

/***/ "./src/katsura.js":
/*!************************!*\
  !*** ./src/katsura.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"tween_btns\": () => (/* binding */ tween_btns),\n/* harmony export */   \"stamp_btn\": () => (/* binding */ stamp_btn),\n/* harmony export */   \"katsura_arr\": () => (/* binding */ katsura_arr),\n/* harmony export */   \"arrBtn_katsura\": () => (/* binding */ arrBtn_katsura)\n/* harmony export */ });\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ \"./src/index.js\");\n\n\nconst tween_btns = gsap.fromTo(\".stamp_btn\", {\n  y: 15,\n  opacity: 0,\n}, {\n  paused: true, // 勝手にアニメーションが始まらないように\n  duration: 1.2,\n  y: 0, // 少し上に移動させる\n  opacity: 1,\n  ease: \"power2.out\",\n  // 複数要素を扱うプロパティ\n  stagger: {\n    from: \"start\", //左側から\n    amount: 0.8 // 0.8秒おきに\n  }\n});\n//cssのホバーでやると動かなかったので改めて設定\nconst stamp_btn = document.querySelectorAll(\".stamp_btn\");\nstamp_btn.forEach((value) => {\n  value.addEventListener(\"mouseover\", () => {\n    value.style.transform = \"scale(0.9)\";\n  });\n  value.addEventListener(\"mouseout\", () => {\n    value.style.transform = \"scale(1)\";\n  });\n});\n\nconst katsuraWidth = 320;\nconst katsuraHeight = 240;\nclass Katsura extends createjs.Bitmap {\n  constructor(img) {\n    super(img);\n    this.regX = katsuraWidth / 2; //画像の真ん中が原点\n    this.regY = katsuraHeight; //画像の一番下が原点\n  }\n  initStamp(posX, posY, scale, rotation) {\n    this.x = posX; //鼻根\n    this.y = posY;\n    this.scale = scale;\n    this.rotation = rotation;//ラジアンを角度に直す\n  }\n}\nclass Katsura1 extends Katsura {\n  constructor() {\n    super(\"../src/img/img_stamp/katsura1.png\");\n  }\n}\nclass Katsura2 extends Katsura {\n  constructor() {\n    super(\"../src/img/img_stamp/katsura2.png\");\n  }\n}\nclass Katsura3 extends Katsura {\n  constructor() {\n    super(\"../src/img/img_stamp/katsura3.png\");\n    this.regX = 360 / 2;\n  }\n}\nclass Katsura4 extends Katsura {\n  constructor() {\n    super(\"../src/img/img_stamp/katsura4.png\");\n  }\n}\nclass Katsura5 extends Katsura {\n  constructor() {\n    super(\"../src/img/img_stamp/katsura5.png\");\n    this.regY = 280;\n  }\n}\nclass Katsura6 extends Katsura {\n  constructor() {\n    super(\"../src/img/img_stamp/katsura6.png\");\n  }\n}\nclass Katsura7 extends Katsura {\n  constructor() {\n    super(\"../src/img/img_stamp/katsura7.png\");\n    this.regY = 230;\n  }\n}\nclass Katsura8 extends Katsura {\n  constructor() {\n    super(\"../src/img/img_stamp/katsura8.png\");\n  }\n}\nclass Katsura9 extends Katsura {\n  constructor() {\n    super(\"../src/img/img_stamp/katsura9.png\");\n    this.regY = 230;\n  }\n}\nclass Katsura10 extends Katsura {\n  constructor() {\n    super(\"../src/img/img_stamp/katsura10.png\");\n    this.regX = 360 / 2;\n    this.regY = 280;\n  }\n}\nclass Katsura11 extends Katsura {\n  constructor() {\n    super(\"../src/img/img_stamp/katsura11.png\");\n  }\n}\nclass Katsura12 extends Katsura {\n  constructor() {\n    super(\"../src/img/img_stamp/katsura12.png\");\n    this.regY = 230;\n  }\n}\n\nconst katsura1 = new Katsura1(),\n  katsura2 = new Katsura2(),\n  katsura3 = new Katsura3(),\n  katsura4 = new Katsura4(),\n  katsura5 = new Katsura5(),\n  katsura6 = new Katsura6(),\n  katsura7 = new Katsura7(),\n  katsura8 = new Katsura8(),\n  katsura9 = new Katsura9(),\n  katsura10 = new Katsura10(),\n  katsura11 = new Katsura11(),\n  katsura12 = new Katsura12();\nconst katsura_arr = [katsura1, katsura2, katsura3, katsura4, katsura5, katsura6, katsura7, katsura8, katsura9, katsura10, katsura11, katsura12];\n\nconst btn_k1 = document.querySelector(\"#btn_k1\"),\n  btn_k2 = document.querySelector(\"#btn_k2\"),\n  btn_k3 = document.querySelector(\"#btn_k3\"),\n  btn_k4 = document.querySelector(\"#btn_k4\"),\n  btn_k5 = document.querySelector(\"#btn_k5\"),\n  btn_k6 = document.querySelector(\"#btn_k6\"),\n  btn_k7 = document.querySelector(\"#btn_k7\"),\n  btn_k8 = document.querySelector(\"#btn_k8\"),\n  btn_k9 = document.querySelector(\"#btn_k9\"),\n  btn_k10 = document.querySelector(\"#btn_k10\"),\n  btn_k11 = document.querySelector(\"#btn_k11\"),\n  btn_k12 = document.querySelector(\"#btn_k12\");\nconst arrBtn_katsura = [btn_k1, btn_k2, btn_k3, btn_k4, btn_k5, btn_k6, btn_k7, btn_k8, btn_k9, btn_k10, btn_k11, btn_k12];\n\nconst removeStamp = () => {\n  katsura_arr.forEach((value) => {\n    _index_js__WEBPACK_IMPORTED_MODULE_0__.stage_katsura.removeChild(value);\n  });\n}\n\nbtn_k1.addEventListener('click', () => {\n  removeStamp();\n  _index_js__WEBPACK_IMPORTED_MODULE_0__.stage_katsura.addChild(katsura1);\n});\nbtn_k2.addEventListener('click', () => {\n  removeStamp();\n  _index_js__WEBPACK_IMPORTED_MODULE_0__.stage_katsura.addChild(katsura2);\n});\nbtn_k3.addEventListener('click', () => {\n  removeStamp();\n  _index_js__WEBPACK_IMPORTED_MODULE_0__.stage_katsura.addChild(katsura3);\n});\nbtn_k4.addEventListener('click', () => {\n  removeStamp();\n  _index_js__WEBPACK_IMPORTED_MODULE_0__.stage_katsura.addChild(katsura4);\n});\nbtn_k5.addEventListener('click', () => {\n  removeStamp();\n  _index_js__WEBPACK_IMPORTED_MODULE_0__.stage_katsura.addChild(katsura5);\n});\nbtn_k6.addEventListener('click', () => {\n  removeStamp();\n  _index_js__WEBPACK_IMPORTED_MODULE_0__.stage_katsura.addChild(katsura6);\n});\nbtn_k7.addEventListener('click', () => {\n  removeStamp();\n  _index_js__WEBPACK_IMPORTED_MODULE_0__.stage_katsura.addChild(katsura7);\n});\nbtn_k8.addEventListener('click', () => {\n  removeStamp();\n  _index_js__WEBPACK_IMPORTED_MODULE_0__.stage_katsura.addChild(katsura8);\n});\nbtn_k9.addEventListener('click', () => {\n  removeStamp();\n  _index_js__WEBPACK_IMPORTED_MODULE_0__.stage_katsura.addChild(katsura9);\n});\nbtn_k10.addEventListener('click', () => {\n  removeStamp();\n  _index_js__WEBPACK_IMPORTED_MODULE_0__.stage_katsura.addChild(katsura10);\n});\nbtn_k11.addEventListener('click', () => {\n  removeStamp();\n  _index_js__WEBPACK_IMPORTED_MODULE_0__.stage_katsura.addChild(katsura11);\n});\nbtn_k12.addEventListener('click', () => {\n  removeStamp();\n  _index_js__WEBPACK_IMPORTED_MODULE_0__.stage_katsura.addChild(katsura12);\n});\n\n\n//# sourceURL=webpack://syjcamera/./src/katsura.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;